#lang racket
(define(next L)
    (if (not (null? L))
        (if (= (first L) 0)
            (cons 1 (rest L))
            (cons 0 (next (rest L)))
        )
        '(1)
    )
)

(next '(0 0 0))
(next '(1 0 0))
(next '(0 1 0))
(next '(1 1 0))
(next '(0 0 1))
(next '(1 0 1))
(next '(0 1 1))
(next '(1 1 1))

(display "\n subs \n")
(define(pred L)
    (if (not (null? L))
        (if (= (first L) 1)
            (cons 0 (rest L))
            (cons 1 (pred (rest L)))
        )
        '()
    )
)

(pred '(0 0 0))
(pred '(1 0 0))
(pred '(0 1 0))
(pred '(1 1 0))
(pred '(0 0 1))
(pred '(1 0 1))
(pred '(0 1 1))
(pred '(1 1 1))

(display "\n binary adder \n")
(define(bAdd A B)
    (if (null? B)
        A
        (if (null? B)
            (cons A (rest B))
            (if (= (first B) 1)
                (cons (first (next A)) (bAdd (rest(next A)) (rest B)))
                (cons (first A) (bAdd (rest(next A)) (rest B)))
            )
        )
    )
)
(bAdd '(1 1 1) '(1 1 0))